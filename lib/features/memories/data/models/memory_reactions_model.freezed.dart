// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'memory_reactions_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

ReactionsSummary _$ReactionsSummaryFromJson(Map<String, dynamic> json) {
  return _ReactionsSummary.fromJson(json);
}

/// @nodoc
mixin _$ReactionsSummary {
  int get like => throw _privateConstructorUsedError;
  int get love => throw _privateConstructorUsedError;
  int get fire => throw _privateConstructorUsedError;
  int get star => throw _privateConstructorUsedError;
  int get celebrate => throw _privateConstructorUsedError;
  int get thinking => throw _privateConstructorUsedError;
  int get total => throw _privateConstructorUsedError;
  ReactionType? get userReaction => throw _privateConstructorUsedError;

  /// Serializes this ReactionsSummary to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ReactionsSummary
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ReactionsSummaryCopyWith<ReactionsSummary> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReactionsSummaryCopyWith<$Res> {
  factory $ReactionsSummaryCopyWith(
    ReactionsSummary value,
    $Res Function(ReactionsSummary) then,
  ) = _$ReactionsSummaryCopyWithImpl<$Res, ReactionsSummary>;
  @useResult
  $Res call({
    int like,
    int love,
    int fire,
    int star,
    int celebrate,
    int thinking,
    int total,
    ReactionType? userReaction,
  });
}

/// @nodoc
class _$ReactionsSummaryCopyWithImpl<$Res, $Val extends ReactionsSummary>
    implements $ReactionsSummaryCopyWith<$Res> {
  _$ReactionsSummaryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ReactionsSummary
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? like = null,
    Object? love = null,
    Object? fire = null,
    Object? star = null,
    Object? celebrate = null,
    Object? thinking = null,
    Object? total = null,
    Object? userReaction = freezed,
  }) {
    return _then(
      _value.copyWith(
            like: null == like
                ? _value.like
                : like // ignore: cast_nullable_to_non_nullable
                      as int,
            love: null == love
                ? _value.love
                : love // ignore: cast_nullable_to_non_nullable
                      as int,
            fire: null == fire
                ? _value.fire
                : fire // ignore: cast_nullable_to_non_nullable
                      as int,
            star: null == star
                ? _value.star
                : star // ignore: cast_nullable_to_non_nullable
                      as int,
            celebrate: null == celebrate
                ? _value.celebrate
                : celebrate // ignore: cast_nullable_to_non_nullable
                      as int,
            thinking: null == thinking
                ? _value.thinking
                : thinking // ignore: cast_nullable_to_non_nullable
                      as int,
            total: null == total
                ? _value.total
                : total // ignore: cast_nullable_to_non_nullable
                      as int,
            userReaction: freezed == userReaction
                ? _value.userReaction
                : userReaction // ignore: cast_nullable_to_non_nullable
                      as ReactionType?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ReactionsSummaryImplCopyWith<$Res>
    implements $ReactionsSummaryCopyWith<$Res> {
  factory _$$ReactionsSummaryImplCopyWith(
    _$ReactionsSummaryImpl value,
    $Res Function(_$ReactionsSummaryImpl) then,
  ) = __$$ReactionsSummaryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    int like,
    int love,
    int fire,
    int star,
    int celebrate,
    int thinking,
    int total,
    ReactionType? userReaction,
  });
}

/// @nodoc
class __$$ReactionsSummaryImplCopyWithImpl<$Res>
    extends _$ReactionsSummaryCopyWithImpl<$Res, _$ReactionsSummaryImpl>
    implements _$$ReactionsSummaryImplCopyWith<$Res> {
  __$$ReactionsSummaryImplCopyWithImpl(
    _$ReactionsSummaryImpl _value,
    $Res Function(_$ReactionsSummaryImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ReactionsSummary
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? like = null,
    Object? love = null,
    Object? fire = null,
    Object? star = null,
    Object? celebrate = null,
    Object? thinking = null,
    Object? total = null,
    Object? userReaction = freezed,
  }) {
    return _then(
      _$ReactionsSummaryImpl(
        like: null == like
            ? _value.like
            : like // ignore: cast_nullable_to_non_nullable
                  as int,
        love: null == love
            ? _value.love
            : love // ignore: cast_nullable_to_non_nullable
                  as int,
        fire: null == fire
            ? _value.fire
            : fire // ignore: cast_nullable_to_non_nullable
                  as int,
        star: null == star
            ? _value.star
            : star // ignore: cast_nullable_to_non_nullable
                  as int,
        celebrate: null == celebrate
            ? _value.celebrate
            : celebrate // ignore: cast_nullable_to_non_nullable
                  as int,
        thinking: null == thinking
            ? _value.thinking
            : thinking // ignore: cast_nullable_to_non_nullable
                  as int,
        total: null == total
            ? _value.total
            : total // ignore: cast_nullable_to_non_nullable
                  as int,
        userReaction: freezed == userReaction
            ? _value.userReaction
            : userReaction // ignore: cast_nullable_to_non_nullable
                  as ReactionType?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ReactionsSummaryImpl implements _ReactionsSummary {
  const _$ReactionsSummaryImpl({
    this.like = 0,
    this.love = 0,
    this.fire = 0,
    this.star = 0,
    this.celebrate = 0,
    this.thinking = 0,
    this.total = 0,
    this.userReaction,
  });

  factory _$ReactionsSummaryImpl.fromJson(Map<String, dynamic> json) =>
      _$$ReactionsSummaryImplFromJson(json);

  @override
  @JsonKey()
  final int like;
  @override
  @JsonKey()
  final int love;
  @override
  @JsonKey()
  final int fire;
  @override
  @JsonKey()
  final int star;
  @override
  @JsonKey()
  final int celebrate;
  @override
  @JsonKey()
  final int thinking;
  @override
  @JsonKey()
  final int total;
  @override
  final ReactionType? userReaction;

  @override
  String toString() {
    return 'ReactionsSummary(like: $like, love: $love, fire: $fire, star: $star, celebrate: $celebrate, thinking: $thinking, total: $total, userReaction: $userReaction)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReactionsSummaryImpl &&
            (identical(other.like, like) || other.like == like) &&
            (identical(other.love, love) || other.love == love) &&
            (identical(other.fire, fire) || other.fire == fire) &&
            (identical(other.star, star) || other.star == star) &&
            (identical(other.celebrate, celebrate) ||
                other.celebrate == celebrate) &&
            (identical(other.thinking, thinking) ||
                other.thinking == thinking) &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.userReaction, userReaction) ||
                other.userReaction == userReaction));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    like,
    love,
    fire,
    star,
    celebrate,
    thinking,
    total,
    userReaction,
  );

  /// Create a copy of ReactionsSummary
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ReactionsSummaryImplCopyWith<_$ReactionsSummaryImpl> get copyWith =>
      __$$ReactionsSummaryImplCopyWithImpl<_$ReactionsSummaryImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$ReactionsSummaryImplToJson(this);
  }
}

abstract class _ReactionsSummary implements ReactionsSummary {
  const factory _ReactionsSummary({
    final int like,
    final int love,
    final int fire,
    final int star,
    final int celebrate,
    final int thinking,
    final int total,
    final ReactionType? userReaction,
  }) = _$ReactionsSummaryImpl;

  factory _ReactionsSummary.fromJson(Map<String, dynamic> json) =
      _$ReactionsSummaryImpl.fromJson;

  @override
  int get like;
  @override
  int get love;
  @override
  int get fire;
  @override
  int get star;
  @override
  int get celebrate;
  @override
  int get thinking;
  @override
  int get total;
  @override
  ReactionType? get userReaction;

  /// Create a copy of ReactionsSummary
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ReactionsSummaryImplCopyWith<_$ReactionsSummaryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CommentAuthor _$CommentAuthorFromJson(Map<String, dynamic> json) {
  return _CommentAuthor.fromJson(json);
}

/// @nodoc
mixin _$CommentAuthor {
  String get userId => throw _privateConstructorUsedError;
  String get username => throw _privateConstructorUsedError;

  /// Serializes this CommentAuthor to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CommentAuthor
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CommentAuthorCopyWith<CommentAuthor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommentAuthorCopyWith<$Res> {
  factory $CommentAuthorCopyWith(
    CommentAuthor value,
    $Res Function(CommentAuthor) then,
  ) = _$CommentAuthorCopyWithImpl<$Res, CommentAuthor>;
  @useResult
  $Res call({String userId, String username});
}

/// @nodoc
class _$CommentAuthorCopyWithImpl<$Res, $Val extends CommentAuthor>
    implements $CommentAuthorCopyWith<$Res> {
  _$CommentAuthorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CommentAuthor
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? userId = null, Object? username = null}) {
    return _then(
      _value.copyWith(
            userId: null == userId
                ? _value.userId
                : userId // ignore: cast_nullable_to_non_nullable
                      as String,
            username: null == username
                ? _value.username
                : username // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$CommentAuthorImplCopyWith<$Res>
    implements $CommentAuthorCopyWith<$Res> {
  factory _$$CommentAuthorImplCopyWith(
    _$CommentAuthorImpl value,
    $Res Function(_$CommentAuthorImpl) then,
  ) = __$$CommentAuthorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String userId, String username});
}

/// @nodoc
class __$$CommentAuthorImplCopyWithImpl<$Res>
    extends _$CommentAuthorCopyWithImpl<$Res, _$CommentAuthorImpl>
    implements _$$CommentAuthorImplCopyWith<$Res> {
  __$$CommentAuthorImplCopyWithImpl(
    _$CommentAuthorImpl _value,
    $Res Function(_$CommentAuthorImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of CommentAuthor
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? userId = null, Object? username = null}) {
    return _then(
      _$CommentAuthorImpl(
        userId: null == userId
            ? _value.userId
            : userId // ignore: cast_nullable_to_non_nullable
                  as String,
        username: null == username
            ? _value.username
            : username // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$CommentAuthorImpl implements _CommentAuthor {
  const _$CommentAuthorImpl({required this.userId, required this.username});

  factory _$CommentAuthorImpl.fromJson(Map<String, dynamic> json) =>
      _$$CommentAuthorImplFromJson(json);

  @override
  final String userId;
  @override
  final String username;

  @override
  String toString() {
    return 'CommentAuthor(userId: $userId, username: $username)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CommentAuthorImpl &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.username, username) ||
                other.username == username));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, userId, username);

  /// Create a copy of CommentAuthor
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CommentAuthorImplCopyWith<_$CommentAuthorImpl> get copyWith =>
      __$$CommentAuthorImplCopyWithImpl<_$CommentAuthorImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CommentAuthorImplToJson(this);
  }
}

abstract class _CommentAuthor implements CommentAuthor {
  const factory _CommentAuthor({
    required final String userId,
    required final String username,
  }) = _$CommentAuthorImpl;

  factory _CommentAuthor.fromJson(Map<String, dynamic> json) =
      _$CommentAuthorImpl.fromJson;

  @override
  String get userId;
  @override
  String get username;

  /// Create a copy of CommentAuthor
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CommentAuthorImplCopyWith<_$CommentAuthorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MemoryCommentModel _$MemoryCommentModelFromJson(Map<String, dynamic> json) {
  return _MemoryCommentModel.fromJson(json);
}

/// @nodoc
mixin _$MemoryCommentModel {
  int get id => throw _privateConstructorUsedError;
  String get memoryId => throw _privateConstructorUsedError;
  CommentAuthor get user => throw _privateConstructorUsedError;
  String get text => throw _privateConstructorUsedError;
  int? get parentId => throw _privateConstructorUsedError;
  int get repliesCount => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime get updatedAt => throw _privateConstructorUsedError;
  bool get isEdited => throw _privateConstructorUsedError;
  List<MemoryCommentModel> get replies => throw _privateConstructorUsedError;

  /// Serializes this MemoryCommentModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MemoryCommentModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MemoryCommentModelCopyWith<MemoryCommentModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MemoryCommentModelCopyWith<$Res> {
  factory $MemoryCommentModelCopyWith(
    MemoryCommentModel value,
    $Res Function(MemoryCommentModel) then,
  ) = _$MemoryCommentModelCopyWithImpl<$Res, MemoryCommentModel>;
  @useResult
  $Res call({
    int id,
    String memoryId,
    CommentAuthor user,
    String text,
    int? parentId,
    int repliesCount,
    DateTime createdAt,
    DateTime updatedAt,
    bool isEdited,
    List<MemoryCommentModel> replies,
  });

  $CommentAuthorCopyWith<$Res> get user;
}

/// @nodoc
class _$MemoryCommentModelCopyWithImpl<$Res, $Val extends MemoryCommentModel>
    implements $MemoryCommentModelCopyWith<$Res> {
  _$MemoryCommentModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MemoryCommentModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? memoryId = null,
    Object? user = null,
    Object? text = null,
    Object? parentId = freezed,
    Object? repliesCount = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? isEdited = null,
    Object? replies = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as int,
            memoryId: null == memoryId
                ? _value.memoryId
                : memoryId // ignore: cast_nullable_to_non_nullable
                      as String,
            user: null == user
                ? _value.user
                : user // ignore: cast_nullable_to_non_nullable
                      as CommentAuthor,
            text: null == text
                ? _value.text
                : text // ignore: cast_nullable_to_non_nullable
                      as String,
            parentId: freezed == parentId
                ? _value.parentId
                : parentId // ignore: cast_nullable_to_non_nullable
                      as int?,
            repliesCount: null == repliesCount
                ? _value.repliesCount
                : repliesCount // ignore: cast_nullable_to_non_nullable
                      as int,
            createdAt: null == createdAt
                ? _value.createdAt
                : createdAt // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            updatedAt: null == updatedAt
                ? _value.updatedAt
                : updatedAt // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            isEdited: null == isEdited
                ? _value.isEdited
                : isEdited // ignore: cast_nullable_to_non_nullable
                      as bool,
            replies: null == replies
                ? _value.replies
                : replies // ignore: cast_nullable_to_non_nullable
                      as List<MemoryCommentModel>,
          )
          as $Val,
    );
  }

  /// Create a copy of MemoryCommentModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CommentAuthorCopyWith<$Res> get user {
    return $CommentAuthorCopyWith<$Res>(_value.user, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MemoryCommentModelImplCopyWith<$Res>
    implements $MemoryCommentModelCopyWith<$Res> {
  factory _$$MemoryCommentModelImplCopyWith(
    _$MemoryCommentModelImpl value,
    $Res Function(_$MemoryCommentModelImpl) then,
  ) = __$$MemoryCommentModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    int id,
    String memoryId,
    CommentAuthor user,
    String text,
    int? parentId,
    int repliesCount,
    DateTime createdAt,
    DateTime updatedAt,
    bool isEdited,
    List<MemoryCommentModel> replies,
  });

  @override
  $CommentAuthorCopyWith<$Res> get user;
}

/// @nodoc
class __$$MemoryCommentModelImplCopyWithImpl<$Res>
    extends _$MemoryCommentModelCopyWithImpl<$Res, _$MemoryCommentModelImpl>
    implements _$$MemoryCommentModelImplCopyWith<$Res> {
  __$$MemoryCommentModelImplCopyWithImpl(
    _$MemoryCommentModelImpl _value,
    $Res Function(_$MemoryCommentModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of MemoryCommentModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? memoryId = null,
    Object? user = null,
    Object? text = null,
    Object? parentId = freezed,
    Object? repliesCount = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? isEdited = null,
    Object? replies = null,
  }) {
    return _then(
      _$MemoryCommentModelImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as int,
        memoryId: null == memoryId
            ? _value.memoryId
            : memoryId // ignore: cast_nullable_to_non_nullable
                  as String,
        user: null == user
            ? _value.user
            : user // ignore: cast_nullable_to_non_nullable
                  as CommentAuthor,
        text: null == text
            ? _value.text
            : text // ignore: cast_nullable_to_non_nullable
                  as String,
        parentId: freezed == parentId
            ? _value.parentId
            : parentId // ignore: cast_nullable_to_non_nullable
                  as int?,
        repliesCount: null == repliesCount
            ? _value.repliesCount
            : repliesCount // ignore: cast_nullable_to_non_nullable
                  as int,
        createdAt: null == createdAt
            ? _value.createdAt
            : createdAt // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        updatedAt: null == updatedAt
            ? _value.updatedAt
            : updatedAt // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        isEdited: null == isEdited
            ? _value.isEdited
            : isEdited // ignore: cast_nullable_to_non_nullable
                  as bool,
        replies: null == replies
            ? _value._replies
            : replies // ignore: cast_nullable_to_non_nullable
                  as List<MemoryCommentModel>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$MemoryCommentModelImpl implements _MemoryCommentModel {
  const _$MemoryCommentModelImpl({
    required this.id,
    required this.memoryId,
    required this.user,
    required this.text,
    this.parentId,
    this.repliesCount = 0,
    required this.createdAt,
    required this.updatedAt,
    this.isEdited = false,
    final List<MemoryCommentModel> replies = const [],
  }) : _replies = replies;

  factory _$MemoryCommentModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$MemoryCommentModelImplFromJson(json);

  @override
  final int id;
  @override
  final String memoryId;
  @override
  final CommentAuthor user;
  @override
  final String text;
  @override
  final int? parentId;
  @override
  @JsonKey()
  final int repliesCount;
  @override
  final DateTime createdAt;
  @override
  final DateTime updatedAt;
  @override
  @JsonKey()
  final bool isEdited;
  final List<MemoryCommentModel> _replies;
  @override
  @JsonKey()
  List<MemoryCommentModel> get replies {
    if (_replies is EqualUnmodifiableListView) return _replies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_replies);
  }

  @override
  String toString() {
    return 'MemoryCommentModel(id: $id, memoryId: $memoryId, user: $user, text: $text, parentId: $parentId, repliesCount: $repliesCount, createdAt: $createdAt, updatedAt: $updatedAt, isEdited: $isEdited, replies: $replies)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MemoryCommentModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.memoryId, memoryId) ||
                other.memoryId == memoryId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            (identical(other.repliesCount, repliesCount) ||
                other.repliesCount == repliesCount) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.isEdited, isEdited) ||
                other.isEdited == isEdited) &&
            const DeepCollectionEquality().equals(other._replies, _replies));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    memoryId,
    user,
    text,
    parentId,
    repliesCount,
    createdAt,
    updatedAt,
    isEdited,
    const DeepCollectionEquality().hash(_replies),
  );

  /// Create a copy of MemoryCommentModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MemoryCommentModelImplCopyWith<_$MemoryCommentModelImpl> get copyWith =>
      __$$MemoryCommentModelImplCopyWithImpl<_$MemoryCommentModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$MemoryCommentModelImplToJson(this);
  }
}

abstract class _MemoryCommentModel implements MemoryCommentModel {
  const factory _MemoryCommentModel({
    required final int id,
    required final String memoryId,
    required final CommentAuthor user,
    required final String text,
    final int? parentId,
    final int repliesCount,
    required final DateTime createdAt,
    required final DateTime updatedAt,
    final bool isEdited,
    final List<MemoryCommentModel> replies,
  }) = _$MemoryCommentModelImpl;

  factory _MemoryCommentModel.fromJson(Map<String, dynamic> json) =
      _$MemoryCommentModelImpl.fromJson;

  @override
  int get id;
  @override
  String get memoryId;
  @override
  CommentAuthor get user;
  @override
  String get text;
  @override
  int? get parentId;
  @override
  int get repliesCount;
  @override
  DateTime get createdAt;
  @override
  DateTime get updatedAt;
  @override
  bool get isEdited;
  @override
  List<MemoryCommentModel> get replies;

  /// Create a copy of MemoryCommentModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MemoryCommentModelImplCopyWith<_$MemoryCommentModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
